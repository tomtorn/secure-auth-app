import type { SignInInput, SignUpInput, User, AuthSession } from '../schemas/index.js';
import { authSessionSchema, userSchema } from '../schemas/index.js';
import { prisma } from '../lib/prisma.js';
import { supabase, supabaseAdmin } from '../lib/supabase.js';
import { logger } from '../lib/logger.js';
import { USER_SELECT } from '../lib/constants.js';
import { AppError, UnauthorizedError } from './errors.js';
import { config } from '../config/index.js';

/**
 * Syncs a Supabase user to the local database.
 * Fix 2.1: Uses supabaseId for upsert to prevent race conditions.
 * - Primary `id` is auto-generated by Prisma (cuid)
 * - `supabaseId` stores the Supabase user ID (unique constraint)
 * - Upsert by supabaseId ensures atomic create-or-update
 *
 * @throws Error if user has no email (required by schema)
 */
const syncUser = async (
  supabaseUser: {
    id: string;
    email?: string;
    user_metadata?: Record<string, unknown>;
    email_confirmed_at?: string | null;
  },
  name?: string | null,
): Promise<User> => {
  // Validate email is present - required by Prisma schema
  if (!supabaseUser.email || supabaseUser.email.trim() === '') {
    logger.error({ supabaseId: supabaseUser.id }, 'Cannot sync user: email is required');
    throw new AppError('User email is required', 400);
  }

  const email = supabaseUser.email;
  const userName = name ?? (supabaseUser.user_metadata?.name as string | null) ?? null;
  const emailVerified = !!supabaseUser.email_confirmed_at;

  // Handle case where user was deleted from Supabase and re-created:
  // The email exists in our DB with a different supabaseId.
  // Solution: Use a transaction to update the existing user's supabaseId.
  return prisma.$transaction(async (tx) => {
    // Check if user exists by email with a DIFFERENT supabaseId
    const existingByEmail = await tx.user.findUnique({
      where: { email },
      select: { id: true, supabaseId: true },
    });

    if (existingByEmail && existingByEmail.supabaseId !== supabaseUser.id) {
      // User exists with different supabaseId (re-registration case)
      // Update the supabaseId to the new one
      logger.info(
        { email, oldSupabaseId: existingByEmail.supabaseId, newSupabaseId: supabaseUser.id },
        'Updating supabaseId for re-registered user',
      );
      return tx.user.update({
        where: { id: existingByEmail.id },
        data: { supabaseId: supabaseUser.id, name: userName, emailVerified },
        select: USER_SELECT,
      });
    }

    // Normal case: upsert by supabaseId
    return tx.user.upsert({
      where: { supabaseId: supabaseUser.id },
      update: { email, name: userName, emailVerified },
      create: { supabaseId: supabaseUser.id, email, name: userName, emailVerified },
      select: USER_SELECT,
    });
  });
};

// Sign up result type - either a session or email confirmation required
export type SignUpResult =
  | { emailConfirmationRequired: true; message: string }
  | { emailConfirmationRequired: false; session: AuthSession };

// Fix 1.4: Generic error messages for signup to prevent user enumeration
// Updated: support Supabase email confirmation flow.
// - When email confirmation is enabled, Supabase returns a user but no session.
// - In that case we sync the user to the local DB and return a success indicating
//   email confirmation is required.
const signUp = async ({ email, password, name }: SignUpInput): Promise<SignUpResult> => {
  const { data, error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      data: { name },
      emailRedirectTo: `${config.frontendUrl}/auth/callback`,
    },
  });

  if (error || !data.user) {
    // Log actual error for debugging (server-side only)
    logger.error({ error: error?.message ?? 'Unknown signup error' }, 'Sign up failed');
    throw new AppError(`Sign up failed: ${error?.message ?? 'Unknown error'}`, 400);
  }

  // When email confirmation is required, Supabase returns a user but no session.
  // The account is created but the user cannot sign in until they confirm.
  if (!data.session) {
    // Keep local user in sync even for unconfirmed accounts
    await syncUser(data.user, name);
    logger.info({ email }, 'Sign up requires email confirmation');
    // Return success with emailConfirmationRequired flag
    return {
      emailConfirmationRequired: true,
      message: 'Please check your email to confirm your account.',
    };
  }

  const dbUser = await syncUser(data.user, name);

  return {
    emailConfirmationRequired: false,
    session: authSessionSchema.parse({
      user: userSchema.parse(dbUser),
      accessToken: data.session.access_token,
      refreshToken: data.session.refresh_token,
      expiresIn: data.session.expires_in,
    }),
  };
};

const signIn = async ({ email, password }: SignInInput): Promise<AuthSession> => {
  const { data, error } = await supabase.auth.signInWithPassword({ email, password });

  if (error) {
    // Log actual error for debugging (server-side only)
    logger.error({ error: error.message }, 'Sign in failed');
    // Return generic message
    throw new UnauthorizedError('Invalid credentials');
  }

  // Supabase may return success but no session (e.g., email not confirmed)
  if (!data.session) {
    logger.warn({ email }, 'Sign in succeeded but no session returned');
    throw new UnauthorizedError('Invalid credentials');
  }

  try {
    const dbUser = await syncUser(data.user);

    return authSessionSchema.parse({
      user: userSchema.parse(dbUser),
      accessToken: data.session.access_token,
      refreshToken: data.session.refresh_token,
      expiresIn: data.session.expires_in,
    });
  } catch (err) {
    // Log actual error server-side for debugging, return generic message to client
    logger.error({ error: err, email }, 'Error during signIn post-auth');
    // Security: Never expose internal error details to clients
    throw new AppError('Authentication failed', 500);
  }
};

const getUserFromToken = async (token: string): Promise<User | null> => {
  const { data, error } = await supabase.auth.getUser(token);
  if (error) return null;

  // Fix: Use supabaseId instead of email for consistency
  // Email can change, supabaseId is immutable
  const supabaseId = data.user.id;
  if (!supabaseId) return null;

  const dbUser = await prisma.user.findUnique({ where: { supabaseId }, select: USER_SELECT });
  return dbUser ? userSchema.parse(dbUser) : null;
};

/**
 * Signs out the user and invalidates the Supabase session.
 * This ensures the access token cannot be reused after signout.
 *
 * Uses supabaseAdmin (service role) because admin.signOut requires elevated permissions.
 */
const signOutUser = async (token: string): Promise<void> => {
  // Use admin client to invalidate session (requires service role key)
  const { error } = await supabaseAdmin.auth.admin.signOut(token);
  if (error) {
    // Log but don't throw - user should still be signed out client-side
    logger.error({ error: error.message }, 'Error invalidating session');
  }
};

export const authService = {
  signUp,
  signIn,
  getUserFromToken,
  signOutUser,
};
